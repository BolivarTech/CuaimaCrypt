//! Cross-compatibility tests: validates Rust output against Java CuaimaCrypt vectors.
//!
//! These vectors were generated by `BTCrypto/test/CrossCompatVectors.java`
//! using password `"TestCrossCompat2024"` with Java 23 and the original
//! CuaimaCrypt v3.1.0 / BTUtils libraries.

use cuaimacrypt::CuaimaCrypt;

// ──────── CuaimaCrypt Internal State ────────

/// Validates that Password() produces identical seeds to the Java implementation.
#[test]
fn test_cuaimacrypt_seeds_match_java() {
    let mut cc = CuaimaCrypt::new();
    cc.password("TestCrossCompat2024").unwrap();

    // Java: seeds[36]
    let expected_seeds: [i64; 36] = [
        1326918708749967616,
        6846395137405223936,
        1433123086778278144,
        7985033786287286272,
        8317015941502830592,
        3216407527824663040,
        7901102437079713792,
        5707000673329759232,
        3526160977682121728,
        5705578590684505088,
        1398009888318091520,
        216089921474330656,
        7733531462421481472,
        331864275915800640,
        2694029768469922304,
        8033139886580361216,
        7573259184891627520,
        3470516764338242560,
        6652707662602372096,
        2031760131312189952,
        6930790883644164096,
        7375066538584852480,
        47644373127766024,
        4485790857871410176,
        4413097300396557312,
        4319998541245973504,
        902511038555128064,
        2505866932943618560,
        566690918481068160,
        7784778508275959808,
        6993316916058703872,
        470864182472081536,
        4022937202432738304,
        1186150692409311488,
        7711886350079053824,
        9080382812459304960,
    ];

    assert_eq!(cc.num_seeds(), 36);
    for (i, &expected) in expected_seeds.iter().enumerate() {
        let actual = cc.get_seed_value(i);
        assert_eq!(
            actual, expected,
            "Seed[{}] mismatch: Rust={}, Java={}",
            i, actual, expected
        );
    }
}

// ──────── CuaimaCrypt Encryption ────────

/// Validates that sequential encryption of 5 blocks matches Java output byte-for-byte.
#[test]
fn test_cuaimacrypt_encrypt_matches_java() {
    let mut cc = CuaimaCrypt::new();
    cc.password("TestCrossCompat2024").unwrap();

    let plaintexts: [[i64; 2]; 5] = [
        [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
        [0, 0],
        [-1, -1],
        [i64::MAX, i64::MIN],
        [42, 84],
    ];

    // Java ciphertext output (sequential encryption)
    let expected_ciphertexts: [[i64; 2]; 5] = [
        [-690786048714755875, -3560020319399875218],
        [4599880280180379900, 1192525439055024488],
        [5894399253817913425, -8438438148590393756],
        [5209606652149623655, -660724922449531431],
        [6570172722744915702, -458128938390824271],
    ];

    for (b, plaintext) in plaintexts.iter().enumerate() {
        let mut block = *plaintext;
        cc.codec(&mut block);
        assert_eq!(
            block, expected_ciphertexts[b],
            "Ciphertext mismatch at block {}: Rust={:?}, Java={:?}",
            b, block, expected_ciphertexts[b]
        );
    }
}

/// Validates that encrypting in Rust and decrypting in Rust recovers original data.
#[test]
fn test_cuaimacrypt_encrypt_decrypt_roundtrip() {
    let mut encoder = CuaimaCrypt::new();
    encoder.password("TestCrossCompat2024").unwrap();

    let mut decoder = CuaimaCrypt::new();
    decoder.password("TestCrossCompat2024").unwrap();

    let plaintexts: [[i64; 2]; 5] = [
        [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
        [0, 0],
        [-1, -1],
        [i64::MAX, i64::MIN],
        [42, 84],
    ];

    for (b, plaintext) in plaintexts.iter().enumerate() {
        let mut block = *plaintext;
        encoder.codec(&mut block);
        decoder.decodec(&mut block);
        assert_eq!(
            block, *plaintext,
            "Roundtrip mismatch at block {}: got {:?}, expected {:?}",
            b, block, plaintext
        );
    }
}

/// Validates that Rust can decrypt ciphertext produced by Java.
#[test]
fn test_cuaimacrypt_decrypt_java_ciphertext() {
    let mut decoder = CuaimaCrypt::new();
    decoder.password("TestCrossCompat2024").unwrap();

    // Java ciphertexts (sequential)
    let ciphertexts: [[i64; 2]; 5] = [
        [-690786048714755875, -3560020319399875218],
        [4599880280180379900, 1192525439055024488],
        [5894399253817913425, -8438438148590393756],
        [5209606652149623655, -660724922449531431],
        [6570172722744915702, -458128938390824271],
    ];

    let expected_plaintexts: [[i64; 2]; 5] = [
        [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
        [0, 0],
        [-1, -1],
        [i64::MAX, i64::MIN],
        [42, 84],
    ];

    for (b, ciphertext) in ciphertexts.iter().enumerate() {
        let mut block = *ciphertext;
        decoder.decodec(&mut block);
        assert_eq!(
            block, expected_plaintexts[b],
            "Decrypt mismatch at block {}: got {:?}, expected {:?}",
            b, block, expected_plaintexts[b]
        );
    }
}

/// Validates multi-block sequential behavior matches Java exactly.
#[test]
fn test_cuaimacrypt_multi_block_sequence() {
    let mut cc1 = CuaimaCrypt::new();
    cc1.password("TestCrossCompat2024").unwrap();

    let mut cc2 = CuaimaCrypt::new();
    cc2.password("TestCrossCompat2024").unwrap();

    // Encrypt 10 blocks with cc1
    let mut blocks: Vec<[i64; 2]> = (0..10)
        .map(|i| [i as i64 * 1000 + 1, i as i64 * 2000 + 2])
        .collect();

    for block in blocks.iter_mut() {
        cc1.codec(block);
    }

    // Decrypt with cc2
    let originals: Vec<[i64; 2]> = (0..10)
        .map(|i| [i as i64 * 1000 + 1, i as i64 * 2000 + 2])
        .collect();

    for (i, block) in blocks.iter_mut().enumerate() {
        cc2.decodec(block);
        assert_eq!(
            *block, originals[i],
            "Multi-block roundtrip failed at block {}",
            i
        );
    }
}
