//! Interoperability certification tests: validates Rust↔Java cross-compatibility.
//!
//! These vectors were generated by `BTCrypto/test/InteropTest.java` using Java 23
//! and CuaimaCrypt v3.1.0 / BTUtils. Each test encrypts in Rust and compares
//! against Java ciphertext, then decrypts the Java ciphertext in Rust and verifies
//! recovery of the original plaintext.

use cuaimacrypt::CuaimaCrypt;

// ──────── Test 1: Multiple Passwords (9 rakes) ────────

/// Standard test plaintexts shared across password tests.
const PLAINTEXTS_6: [[i64; 2]; 6] = [
    [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
    [0, 0],
    [-1, -1],
    [i64::MAX, i64::MIN],
    [42, 84],
    [0xDEADBEEFCAFEBABE_u64 as i64, 0x1234567890ABCDEF_u64 as i64],
];

#[test]
fn test_interop_password_simple_pass() {
    let java_ct: [[i64; 2]; 6] = [
        [849666330237489045, -6130052923606819009],
        [-525563417905767536, -4793497959211673032],
        [-2272123302336721753, 4398321531180905189],
        [3879941276249797866, 7035941502985965971],
        [-2143719545029669236, 8045378908884241578],
        [8889943490941873086, -1476031953138209398],
    ];
    verify_encrypt_and_decrypt("SimplePass", 9, &PLAINTEXTS_6, &java_ct);
}

#[test]
fn test_interop_password_special_chars() {
    let java_ct: [[i64; 2]; 6] = [
        [7117489852754688544, 7943731951873143049],
        [-6425103574502881780, -707558400516062676],
        [7941478036748362328, -9093893033004680271],
        [6678671132456365225, -775736099354419871],
        [2961952357815190336, -7670097522900430604],
        [5570606552441195372, -6021642916778368],
    ];
    verify_encrypt_and_decrypt("CuaimaCrypt2024!@#$%", 9, &PLAINTEXTS_6, &java_ct);
}

#[test]
fn test_interop_password_single_char() {
    let java_ct: [[i64; 2]; 6] = [
        [-7420597100884727976, 5415392412480063833],
        [7611350997898439385, -8352750119531296231],
        [4538173908318362105, -3617987732530049977],
        [711775525423987525, 3926112468346701452],
        [-7788049249875565954, 987416006646853873],
        [-2077247544594290826, 3856427528391013401],
    ];
    verify_encrypt_and_decrypt("A", 9, &PLAINTEXTS_6, &java_ct);
}

#[test]
fn test_interop_password_long() {
    let java_ct: [[i64; 2]; 6] = [
        [-8317928497970355329, 1840524908178594560],
        [1092003535984615099, 501903680362304331],
        [5966221587611187687, -2764745351883825917],
        [-1352790836728005799, 2386867178997251020],
        [-6001077449729908051, -7939753434243459539],
        [5941602641897284098, -5104896555028664030],
    ];
    verify_encrypt_and_decrypt(
        "The quick brown fox jumps over the lazy dog 1234567890",
        9,
        &PLAINTEXTS_6,
        &java_ct,
    );
}

// ──────── Test 2: Custom Rake Counts ────────

const PLAINTEXTS_3: [[i64; 2]; 3] = [
    [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
    [42, 84],
    [-1, -1],
];

#[test]
fn test_interop_rakes_2() {
    let java_ct: [[i64; 2]; 3] = [
        [-9167095909547070505, -1714457271961530704],
        [-8276998167269393313, 1865687446229941749],
        [7377298495125100735, -5377255324178503877],
    ];
    verify_encrypt_and_decrypt("InteropTestRakes2024", 2, &PLAINTEXTS_3, &java_ct);
}

#[test]
fn test_interop_rakes_5() {
    let java_ct: [[i64; 2]; 3] = [
        [5097420390507318065, -6407544924048570704],
        [-4041891697537562882, -587681561427208777],
        [1100351430133146049, -8768351605133121222],
    ];
    verify_encrypt_and_decrypt("InteropTestRakes2024", 5, &PLAINTEXTS_3, &java_ct);
}

#[test]
fn test_interop_rakes_16() {
    let java_ct: [[i64; 2]; 3] = [
        [8967944393360212520, 1340722443277124016],
        [-4339307819765447978, -7654723523528238985],
        [1787725380670730751, -103086069505471523],
    ];
    verify_encrypt_and_decrypt("InteropTestRakes2024", 16, &PLAINTEXTS_3, &java_ct);
}

// ──────── Test 3: 20-block sequential ────────

#[test]
fn test_interop_long_sequence_20_blocks() {
    let java_ct: [[i64; 2]; 20] = [
        [377680776273981781, 5773899133482046325],
        [1942090782882329102, -4728564760913973686],
        [7551085206213579383, 722646484871586018],
        [4312132513932360492, -1442917758692840511],
        [1307118771375192136, 5496612336348548080],
        [-8668637413351893164, -6336788472323688323],
        [-1902898834210242635, -5881102639494571178],
        [7046036105984236651, -5824381261982384982],
        [8399744033127504296, -1277416675789069820],
        [-8283859248570936013, 4234500355957213661],
        [7058315035097428558, 7125301093558395557],
        [-8583267069624141790, -7456424811332727991],
        [4283256070747208629, -4311548981920347463],
        [8871821824368602995, 5806368631685210264],
        [-8602536046598315884, -6744659580687358381],
        [4993613034830604721, 513396698712906971],
        [6436327272697159904, 5648812125236707885],
        [9025636400100290373, 3183503296605529772],
        [1425512819134615212, -7860235244802281504],
        [-7485257966204550992, -2980597561123713728],
    ];

    let plaintexts: Vec<[i64; 2]> = (0..20)
        .map(|b| [b as i64 * 1000 + 1, b as i64 * 2000 + 2])
        .collect();

    // Rust encrypt must match Java ciphertext
    let mut encoder = CuaimaCrypt::new();
    encoder.password("LongSequence2024").unwrap();
    for (b, pt) in plaintexts.iter().enumerate() {
        let mut block = *pt;
        encoder.codec(&mut block);
        assert_eq!(
            block, java_ct[b],
            "Encrypt mismatch at block {}: Rust={:?}, Java={:?}",
            b, block, java_ct[b]
        );
    }

    // Rust decrypt of Java ciphertext must recover plaintext
    let mut decoder = CuaimaCrypt::new();
    decoder.password("LongSequence2024").unwrap();
    for (b, ct) in java_ct.iter().enumerate() {
        let mut block = *ct;
        decoder.decodec(&mut block);
        assert_eq!(
            block, plaintexts[b],
            "Decrypt mismatch at block {}: got={:?}, expected={:?}",
            b, block, plaintexts[b]
        );
    }
}

// ──────── Test 4: Unicode password ────────

#[test]
fn test_interop_unicode_password() {
    let java_ct: [[i64; 2]; 2] = [
        [-6760090877418657103, 1276413442268669263],
        [-3033038814096121036, -4059272936811105735],
    ];

    let plaintexts: [[i64; 2]; 2] = [
        [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
        [42, 84],
    ];

    // "ClaéMóndéüñal2024" in Rust string literal (UTF-8)
    let password = "Cla\u{00e9}M\u{00f3}nd\u{00e9}\u{00fc}\u{00f1}al2024";

    verify_encrypt_and_decrypt(password, 9, &plaintexts, &java_ct);
}

// ──────── Test 5: Rust internal roundtrip (sanity) ────────

#[test]
fn test_rust_roundtrip_sanity() {
    let password = "RoundtripSanity2024";
    let mut encoder = CuaimaCrypt::new();
    encoder.password(password).unwrap();
    let mut decoder = CuaimaCrypt::new();
    decoder.password(password).unwrap();

    let plaintexts: [[i64; 2]; 5] = [
        [0x0123456789ABCDEF_u64 as i64, 0xFEDCBA9876543210_u64 as i64],
        [0, 0],
        [-1, -1],
        [i64::MAX, i64::MIN],
        [42, 84],
    ];

    for (b, pt) in plaintexts.iter().enumerate() {
        let mut block = *pt;
        encoder.codec(&mut block);
        decoder.decodec(&mut block);
        assert_eq!(
            block, *pt,
            "Rust roundtrip mismatch at block {}: got={:?}, expected={:?}",
            b, block, pt
        );
    }
}

// ──────── Helper ────────

/// Verifies both directions:
/// 1. Rust encrypt produces the same ciphertext as Java
/// 2. Rust decrypt of Java ciphertext recovers original plaintext
fn verify_encrypt_and_decrypt(
    password: &str,
    num_rakes: usize,
    plaintexts: &[[i64; 2]],
    java_ct: &[[i64; 2]],
) {
    assert_eq!(plaintexts.len(), java_ct.len());

    // Direction 1: Rust encrypt must match Java ciphertext
    let mut encoder = if num_rakes == 9 {
        CuaimaCrypt::new()
    } else {
        CuaimaCrypt::with_num_rakes(num_rakes).unwrap()
    };
    encoder.password(password).unwrap();

    for (b, pt) in plaintexts.iter().enumerate() {
        let mut block = *pt;
        encoder.codec(&mut block);
        assert_eq!(
            block, java_ct[b],
            "ENCRYPT mismatch at block {} (password={}, rakes={}): Rust={:?}, Java={:?}",
            b, password, num_rakes, block, java_ct[b]
        );
    }

    // Direction 2: Rust decrypt of Java ciphertext must recover plaintext
    let mut decoder = if num_rakes == 9 {
        CuaimaCrypt::new()
    } else {
        CuaimaCrypt::with_num_rakes(num_rakes).unwrap()
    };
    decoder.password(password).unwrap();

    for (b, ct) in java_ct.iter().enumerate() {
        let mut block = *ct;
        decoder.decodec(&mut block);
        assert_eq!(
            block, plaintexts[b],
            "DECRYPT mismatch at block {} (password={}, rakes={}): got={:?}, expected={:?}",
            b, password, num_rakes, block, plaintexts[b]
        );
    }
}
